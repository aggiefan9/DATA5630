# -*- coding: utf-8 -*-
"""TS_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nfjmIJSn4IhZXVwMl_IAoBbfLFDka7B3
"""

# Author: Hannah Davies
# Date: 2024-11-22


import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sktime.forecasting.ets import AutoETS
from sktime.forecasting.arima import AutoARIMA
from sklearn.ensemble import RandomForestRegressor
from sktime.forecasting.base import ForecastingHorizon
from tensorflow.keras.utils import timeseries_dataset_from_array
from tensorflow.keras.layers import Input, Dense, SimpleRNN
from tensorflow.keras.models import Model

def manual_train_test_split(y, train_size):
    split_point = int(len(y) * train_size)
    return y[:split_point], y[split_point:]
    
def get_x_y(df, target, train_size, num_lags):
    data = df.copy()
    series = data[target].dropna().to_numpy()
    lag_names = []
    for x in range(num_lags):
        lag = np.roll(series, 1)
        data[f'lag-{x+1}'] = lag
        lag_names.append(f'lag-{x+1}')

    X = np.array(data[lag_names])
    Y = data[[target]]
    split_point = int(len(data) * train_size)
    x_train, y_train = X[num_lags:split_point], Y[num_lags:split_point]
    x_test, y_test = X[split_point:], Y[split_point:]
    
    return x_train, y_train, x_test, y_test

def rnn_train_test_split(y, train_size, sequence_length=60, batch_size=32, units=0, epochs=0):
    split_point = int(len(y) * train_size)
    delay = sequence_length + 1 - 1

    train_dataset = timeseries_dataset_from_array(
        data=y[:-delay],
        targets=y[delay:],
        sequence_length=sequence_length,
        shuffle=False,
        batch_size=batch_size,
        start_index=0,
        end_index=split_point)

    test_dataset = timeseries_dataset_from_array(
        data=y[:-delay],
        targets=y[delay:],
        sequence_length=sequence_length,
        shuffle=False,
        batch_size=batch_size,
        start_index=split_point)
    
    return train_dataset, test_dataset

def build_rnn_model(sequence_length=60, units=50, batch_size=0, epochs=0):
    inputs = Input(shape=(sequence_length, 1))
    x = SimpleRNN(units, return_sequences=True)(inputs)
    x = SimpleRNN(units//2, return_sequences=False)(x)
    outputs = Dense(1)(x)
    model = Model(inputs, outputs)
    
    model.compile(optimizer="rmsprop", loss="mse", metrics=["mae"])

    return model

def run_forecast(x_train, y_train, x_test, y_test, model, fh, **kwargs):
    if model == 'ETS':
        forecaster = AutoETS(**kwargs)
    elif model == 'ARIMA':
        forecaster = AutoARIMA(**kwargs)
    elif model == 'Random Forest':
        forecaster = RandomForestRegressor(**kwargs)
    elif model == 'RNN':
        forecaster = build_rnn_model(**kwargs)
    else:
        raise ValueError("Unsupported model")

    if model == 'Random Forest':
        forecaster.fit(x_train, y_train)
        y_pred_array = forecaster.predict(x_test)

        y_forecast_array = []

        input_X = x_test[-1]

        while len(y_forecast_array) < fh:
            prediction = forecaster.predict(input_X.reshape(1, -1))[0]
            y_forecast_array.append(prediction)

            input_X = np.roll(input_X, -1)
            input_X[-1] = prediction

        y_pred = pd.Series(y_pred_array, index=y_test.index)
        forecast_index = pd.period_range(start=y_test.index[-1] + 1, periods=fh, freq=y_train.index.freq)
        y_forecast = pd.Series(y_forecast_array, index=forecast_index)
    elif model == 'RNN':
        forecaster.fit(x_train, epochs=kwargs.get("epochs", 50), verbose=0)
        last_sequence = y_train[-kwargs.get("sequence_length", 60):].values.reshape(1, kwargs.get("sequence_length", 60), 1)
        y_pred_array = []
        for i in range(len(y_test)):
            prediction = forecaster.predict(last_sequence)[0,0]
            y_pred_array.append(prediction)

            # Update the input sequence
            last_sequence = np.roll(last_sequence, -1, axis=1)
            last_sequence[0, -1, 0] = y_test.iloc[i]
        
        # Generate future forecasts
        last_sequence = y_test[-kwargs.get("sequence_length", 60):].values.reshape(1, kwargs.get("sequence_length", 60), 1)
        y_forecast_array = []
        for _ in range(fh):
            prediction = forecaster.predict(last_sequence)[0,0]
            y_forecast_array.append(prediction)

            # Update the input sequence
            last_sequence = np.roll(last_sequence, -1, axis=1)
            last_sequence[0, -1, 0] = prediction

        y_pred = pd.Series(y_pred_array, index=y_test.index)
        last_date = y_test.index[-1]
        future_dates = pd.period_range(start=last_date + 1, periods=fh, freq=y_train.index.freq)
        y_forecast = pd.Series(y_forecast_array, index=future_dates)
    else:
        forecaster.fit(y_train)
        y_pred = forecaster.predict(fh=ForecastingHorizon(y_test.index, is_relative=False))

        last_date = y_test.index[-1]
        future_dates = pd.period_range(start=last_date + 1, periods=fh, freq=y_train.index.freq)
        future_horizon = ForecastingHorizon(future_dates, is_relative=False)
        y_forecast = forecaster.predict(fh=future_horizon)

    return forecaster, y_pred, y_forecast

def plot_time_series(y_train, y_test, y_pred, y_forecast, model, target):
    fig, ax = plt.subplots(figsize=(12, 6))
    ax.plot(y_train.index.to_timestamp(), y_train.values, label="Train")
    ax.plot(y_test.index.to_timestamp(), y_test.values, label="Test")
    ax.plot(y_pred.index.to_timestamp(), y_pred.values, label="Test Predictions")
    ax.plot(y_forecast.index.to_timestamp(), y_forecast.values, label="Forecast")
    plt.legend()
    plt.title(f"{model} Forecast for {target}")
    plt.xlabel("Date")
    plt.ylabel("Value")
    return fig



def main():
    st.set_page_config(layout="wide")
    st.title("Time Series Forecasting App")

    col1, col2, col3 = st.columns([1.5, 3.5, 5])

    with col1:
        st.header("Model Assumptions")
        country_choice = st.selectbox("Select a country", ["United States", "Australia", "Japan", "Switzerland"])
        model_choice = st.selectbox("Select a model", ["ETS", "ARIMA", "Random Forest", "RNN"])
        train_size = st.slider("Train size (%)", 50, 95, 80) / 100

        if model_choice == "ETS":
            error = st.selectbox("Error type", ["add", "mul"])
            trend = st.selectbox("Trend type", ["add", "mul", None])
            seasonal = st.selectbox("Seasonal type", ["add", "mul", None])
            damped_trend = st.checkbox("Damped trend", value=False)
            seasonal_periods = st.number_input("Seasonal periods", min_value=1, value=1)
            model_params = {
                "error": error,
                "trend": trend,
                "seasonal": seasonal,
                "damped_trend": damped_trend,
                "sp": seasonal_periods,
            }
        elif model_choice == "ARIMA":
            st.subheader("Non-seasonal")
            start_p = st.number_input("Min p", min_value=0, value=0)
            max_p = st.number_input("Max p", min_value=0, value=5)
            start_q = st.number_input("Min q", min_value=0, value=0)
            max_q = st.number_input("Max q", min_value=0, value=5)
            d = st.number_input("d", min_value=0, value=1)

            st.subheader("Seasonal")
            seasonal = st.checkbox("Seasonal", value=True)
            if seasonal:
                start_P = st.number_input("Min P", min_value=0, value=0)
                max_P = st.number_input("Max P", min_value=0, value=2)
                start_Q = st.number_input("Min Q", min_value=0, value=0)
                max_Q = st.number_input("Max Q", min_value=0, value=2)
                D = st.number_input("D", min_value=0, value=1)
                sp = st.number_input("Periods", min_value=1, value=12)

            model_params = {
                "start_p": start_p,
                "max_p": max_p,
                "start_q": start_q,
                "max_q": max_q,
                "d": d,
                "seasonal": seasonal,
            }
            if seasonal:
                model_params.update({
                    "start_P": start_P,
                    "max_P": max_P,
                    "start_Q": start_Q,
                    "max_Q": max_Q,
                    "D": D,
                    "sp": sp
                })
        elif model_choice == "Random Forest":
            st.subheader("Random Forest Hyperparameters")
            n_estimators = st.number_input("Number of Trees (n_estimators)", min_value=10, value=100, step=10)
            max_depth = st.number_input("Max Depth (None for unlimited)", min_value=1, value=None)
            random_state = st.number_input("Random State (for reproducibility)", min_value=0, value=42)
            num_lags = st.number_input("Lags", min_value=0, value=12)
            model_params = {
                "n_estimators": n_estimators,
                "max_depth": max_depth if max_depth else None,
                "random_state": random_state,
            }
        elif model_choice == "RNN":
            st.subheader("RNN Hyperparameters")
            sequence_length = st.number_input("Sequence Length", min_value=1, value=60)
            units = st.number_input("Number of RNN Units", min_value=1, value=50)
            epochs = st.number_input("Number of Training Epochs", min_value=1, value=10)
            batch_size = st.number_input("Batch Size", min_value=1, value=10)
            model_params = {
                "sequence_length": sequence_length,
                "units": units,
                "epochs": epochs,
                "batch_size": batch_size,
            }

    with col2:
        st.header("Data Handling")
        uploaded_file = st.file_uploader("Choose a CSV file", type="csv")
        if uploaded_file is not None:
            try:
                # Read the CSV file
                df = pd.read_csv(uploaded_file)

                # filter dataset by selected country
                if country_choice == "United States":
                    df = df[df['country'] == 'United States']

                elif country_choice == "Australia":
                    df = df[df['country'] == 'Australia']

                elif country_choice == "Japan":
                    df = df[df['country'] == 'Japan']

                else:
                    df = df[df['country'] == 'Switzerland']


                # Allow user to select the frequency
                freq_options = ['D', 'W', 'M', 'Q', 'Y']
                freq = st.selectbox("Select the data frequency", freq_options)

                # Convert the index to datetime and then to PeriodIndex
                df['date'] = pd.to_datetime(df.iloc[:, 0], errors='coerce')
                df = df.set_index('date')
                df = df.sort_index()  # Ensure the index is sorted
                df.index = df.index.to_period(freq)
                # df = df.groupby([df.index, 'country']).sum()

                # Remove any rows with NaT in the index
                df = df.loc[df.index.notnull()]

                st.subheader("Data Preview")
                st.write(df.head())

                # Filter out non-numeric columns
                numeric_columns = df.select_dtypes(include=[np.number]).columns.tolist()

                if not numeric_columns:
                    st.error("No numeric columns found in the uploaded data. Please ensure your CSV contains numeric data for forecasting.")
                else:
                    target_variable = st.selectbox("Select your target variable", numeric_columns)

                    # Plot the time series of the selected target variable
                    st.subheader(f"Time Series Plot: {target_variable}")
                    fig, ax = plt.subplots(figsize=(10, 4))
                    ax.plot(df.index.to_timestamp(), df[target_variable])
                    plt.title(f"{target_variable} Time Series")
                    plt.xlabel("Date")
                    plt.ylabel("Value")
                    st.pyplot(fig)

            except Exception as e:
                st.error(f"An error occurred while processing the file: {str(e)}")
                st.error("Please ensure your CSV file is properly formatted with a date column and numeric data for forecasting.")

    with col3:
        st.header("Forecast Results")
        fh = st.number_input("Number of periods to forecast", min_value=1, value=10)
        run_forecast_button = st.button("Run Forecast")

        if run_forecast_button:
            if 'df' in locals() and 'target_variable' in locals():
                try:
                    y = df[target_variable]

                    # Perform train-test split
                    y_train, y_test = manual_train_test_split(y, train_size)

                    if model_choice == 'Random Forest':
                        x_train, y_train, x_test, y_test = get_x_y(df, target_variable, train_size, num_lags)
                        forecaster, y_pred, y_forecast = run_forecast(x_train, y_train, x_test, y_test, model_choice, fh, **model_params)
                    elif model_choice == 'RNN':
                        x_train, x_test = rnn_train_test_split(y, train_size, **model_params)
                        forecaster, y_pred, y_forecast = run_forecast(x_train, y_train, x_test, y_test, model_choice, fh, **model_params)
                    else:
                        forecaster, y_pred, y_forecast = run_forecast(None, y_train, None, y_test, model_choice, fh, **model_params)

                    fig = plot_time_series(y_train, y_test, y_pred, y_forecast, model_choice, target_variable)
                    st.pyplot(fig)

                    st.subheader("Test Set Predictions")
                    st.write(y_pred)

                    st.subheader("Future Forecast Values")
                    st.write(y_forecast)
                except Exception as e:
                    st.error(f"An error occurred during forecasting: {str(e)}")
            else:
                st.warning("Please upload data and select a target variable before running the forecast.")

if __name__ == "__main__":
    main()